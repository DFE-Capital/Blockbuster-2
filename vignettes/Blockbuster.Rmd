---
title: "Blockbuster modelling: wow; what a difference!"
author: "Matthew Gregory and Peter Curtis"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{blockbuster_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> Can I have a P please, Bob?.
([via](http://www.bbc.co.uk/news/entertainment-arts-16447409))

## Modelling  deterioration of the School Estate using Discrete-Time Markov chains

A useful package of functions and sample data to forecast the future condition
of School blocks (or buildings) in the UK.

### Modelling overview

Markov chains represent a class of stochastic processes of great interest for
the wide spectrum of practical applications. In particular, discrete time 
[Markov chains](https://cran.r-project.org/web/packages/markovchain/vignettes/an_introduction_to_markovchain_package.pdf) (DTMC) permit modelling the transition probabilities
between discrete states by the aid of matrices. The states are represented by
the `grade` factor which is the surveyed condition of a building element,
determined by a quantity surveyor through grades (states); A, B, C, D, E. The
transition probabilities are 6 by 6 matrices with the average deterioration rate
per timestep between states provided by expert building consultant opinion (see
documentation for full details).  

### Business questions it can answer

This package is useful for decision makers as it provides a modelling approach
for predicting the average condition of an individual building component
(`elementid`) through time. This modelling approach can be scaled through a
decision making hierarchy, with modelling the deterioration at the level of a
School block (`buildingid`), for each site (`siteid`), the School (which may be
made of many blocks, `URN`), at the Local Authority (LA)
level (`LAN`) and at the National level given suitable input data (filter
desired rows using the `dplyr` package is recommended).  

The `Blockbuster` function can be used on data containing one or more components
in one or more school blocks.  Individual component level information is stored as a data.frame with strict conditions on columns
while block-level information is held in another
data.frame with strictly defined columns. It produces snapshots of the 
component and block conditions at each timestep. The model can be applied to
individual components, buildings, collections of buildings, or the entire
estate. This flexibility allows decision makers to ask many and varied questions
of the output data.  

## Using the package

Check you have these packages installed and then load them into memory using
`library()` or `require()`.

```{r warning=FALSE, message=FALSE, error=FALSE}
library(blockbuster2)
```

To run a 10 year simulation of the provided simulated dataset, with no rebuilding and £1bn of repair funds per year, the command is

`Blockbuster(simulated_elements, forecast.horizon = 1, rebuild.money = 0, repair.money = 1000000000)`

 Note that the Blockbuster automatically saves yearly states into files called
  `blockbuster_output_element_*.rds` and `blockbuster_output_block_*.rds`within
  an `output` sub-folder of the current working directory that the function will
  create if it does not already exist.  The complete output is saved as 
  `blockbuster_output_output.rds`.  This behaviour is customisable.  Saving of
  outputs can be turned off with `save = FALSE` passed as an argument. Alternatively, the path and filename can be adjusted using the `filelabel` and `path` arguments.
  
  The element level output is a copy of the input, but with updated grade probabilities and repair totals.  Note that the the cost of repairing an element at
  a given grade is given by the `*.repair.total` column.  The `*.repair.cost` column is the unit cost of repairing that component type.
  
  Passing numeric vectors to the `rebuild.money` and `repair.money` arguments allows control of the amount of money available for rebuilding and repairing each year respectively.

## Inputs and Outputs Overview

Remember to use the R help for all of the functions and data mentioned in the
vignette for extra detail (e.g. try typing `?Blockbuster` into the console).

## Input format

The first argument for the Blockbuster function is a data.frame containing the data for the elements that you wish to simulate. The package contains some simulated data in the correct format under the name `simulated_elements`.

```{r}
data("simulated_elements", package = "blockbuster2")
dplyr::glimpse(simulated_elements)
```

For use with blockbuster, the data.frame must contain the following columns:

--------------------------------------------------------------
Column              Description 
--------------      -----------------------------------------------------------
buildingid          A number that uniquely identifies the building a component
                    is part of
                    
A                   The probability the element is at grade A
 
B                   The probability the element is at grade B

C                   The probability the element is at grade C

D                   The probability the element is at grade D

E                   The probability the element is at grade E 

ab                  The probability that the component will deteriorate from 
                    grade A to grade B in one year
                  
bc                  The probability that the component will deteriorate from
                    grade B to grade C in one year
                   
cd                  The probability that the component will deteriorate from
                    grade C to grade D in one year
                   
de                  The probability that the component will deteriorate from 
                    grade D to grade E in one year
                   
unit_area           A quantification of the size of the component - this is 
                    usually an area but could be a count or length
                   
B.repair.cost       The cost to repair one unit_area of this component at grade B
 
C.repair.cost       The cost to repair one unit_area of this component at grade C

D.repair.cost       The cost to repair one unit_area of this component at grade D

E.repair.cost       The cost to repair one unit_area of this component at grade E

gifa                The Gross Internal Floor Area of the building a component is
                    part of. This is used to generate the cost of rebuilding the
                    entire building

-------------------------------------------------------------

The simulated data provided with the package also contains the following column that is not used internally but could be useful when analyzing outputs:

-----------------------------
Column     Description
---------- --------------------------------------------------
elementid  A number that identifies the component type
-----------------------------


The package is designed to be used with PDS data which also includes the following columns that can be useful when looking at outputs:

--------------------------------
Column  Description
------- ----------------------------------------------------------------------
URN     A number that uniquely identifies a school 

siteid  A number that uniquely identifies a school site (schools may have more than one site) 

LAN     A number that uniquely identifies a Local Authority
----------------------------------

## Output format

The model output is a nested list, with the first level indicating the year of simulation (including the original input at position 1) and within each year, data.frames for both element- and block-level data.

So, `output[[1]]$element` will return the input element data (as the input is the first list element), while `output[[2]]$block` will return the block-level summary after one year of simulation.

The element-level data.frames are structured in the same way as required for the input, while the block-level data.frames includes columns that total the expected repair cost for each block at each grade, the cost to rebuild the entire block and the ratio between the total repair cost and the rebuild cost.

The package also includes a block-level summary of the simulated data as `simulated_blocks`

```{r}
data("simulated_blocks", package = "blockbuster2")
dplyr::glimpse(simulated_blocks)
```

This is the same format as the block-level summary outputs of the model.

As mentioned previously, by default the Blockbuster function saves outputs to files.  Files can be loaded individually into your session using something akin to `load("./output/blockbuster_element_2.rds")` depending on where you set the `save`, `path` and `filelabel` arguments.

## Example analysis

Here we simulate the deterioration of one building through one year.

```{r, warnings = FALSE, collapse = TRUE}
#  output demonstration

# construct single block input
my_output <- Blockbuster(simulated_elements, save = FALSE)
dplyr::glimpse(my_output) # this function makes the output nicer to read
```

The first list entry is the initial state, split into two data frames, the element-level data and the block-level summary.  The second list entry is the model output after one year.  If we forecast more years, there will be an addition list element for each year.

For convenience there are four useful functions for managing the output.  `pull_Element_Data` and `pull_Block_Data` can be used to pull out the element- and block-level data from the output. For large datasets (for example, the PDS dataset), R can hit memory limits when the `Blockbuster` function tries to construct the single output object from the saved interim files. `load_Block_Data` and `load_Element_Data` load the relevant outputs from the saved files.  These functions have a dependency on the `tidyr` package, so you will need to load it if you want to use these convenient functions for looking at the outputs.

```{r}
library(tidyr)
```

We start by looking at the block-level output.

```{r, collapse = TRUE}
my_block <- pull_Block_Data(my_output)
glimpse(my_block)
```

Note that the `pull_Block_Data` combines the outputs for all years into one data frame, adds a `year` column and places the grades and backlog into tidy format. This makes it easier to filter and plot the data.  

For example, let's look at all the blocks with an expected grade D backlog after one year of over £100,000:

```{r}
my_block %>% filter(year == 1, grade == "D", backlog > 100000)
```
Or we could rank the blocks in order of their total backlog after one year:

```{r}
my_block %>%
  filter(year == 1) %>%
  group_by(buildingid) %>%
  summarise(total = sum(backlog)) %>%
  arrange(desc(total))
```

Here we use `ggplot2` to plot the backlog for each grade over time.

```{r}
library(ggplot2)
my_block %>% group_by(year, grade) %>%
  summarise(backlog = sum(backlog)) %>%
  ggplot() +
  geom_line(aes(x = year, y = backlog, colour = grade))
```

The `pull_Element_Data` and `load_Element_Data` functions work in the same way, but with 
an extra argument called `type`.  If `type` is `"area"` then the resulting data frame will contain the proportional area at each grade in tidy format.  If `type` is `"backlog"` then the backlog at each grade will be in tidy format.  If `type` is anything else then the output will be the raw data.

```{r}
pull_Element_Data(my_output) %>% glimpse
pull_Element_Data(my_output, type = "area") %>% glimpse
pull_Element_Data(my_output, type = "backlog") %>% glimpse
```

<!-- This output has foreign key variables with the suffix -id, that could be joined  -->
<!-- to other data from relevant SQL data tables (e.g. the user could find the `urn` -->
<!-- by joining on `siteid` from an appropriate data table). The `urn` is omitted to -->
<!-- maintain the anonymity of each school's condition included in the sample.   -->

<!-- #### Generic methods -->

<!-- There are currently no generic methods associated with the `blockbuster` class, -->
<!-- but we plan to implement methods for `summary`, `print` and `plot`. -->

<!-- ### The default arguments -->

<!-- In the example above we passed the `blockbuster` function only one argument and -->
<!-- it still worked. That is because if you do not explicitly state some of the -->
<!-- arguments it will assume default values for these. We can look at the defaults -->
<!-- using the `formals` function.   -->

<!-- ```{r} -->
<!-- formals(Blockbuster) -->
<!-- ``` -->

<!-- The default behaviour of the model is to simulate deterioration over one year -->
<!-- without any rebuilding or repairing and no inflation.  The argument -->
<!-- `element.data` does not have default behaviour thus we must pass it to -->
<!-- the blockbuster function. -->

<!-- For more detail try typing `?blockbuster` into the console.   -->

<!-- ## The transition probability data -->

<!-- The deterioration rates are stored in the input `element` object, allowing for  -->
<!-- individually tailored deterioration rates if desired. Let's inspect  -->
<!-- some rates in `test.element`. -->

<!-- ```{r} -->
<!-- test.element[1:2, ] %>% -->
<!--   select(elementid, na, ab, bc, cd, de) -->
<!-- ``` -->

<!-- This identifies the building component through the `elementid`. Although not -->
<!-- available yet, the `TOBEINCLUDED` file in the data folder details the element, -->
<!-- sub-element and construction type associated with each `elementid`. The -->
<!-- "two-letter" variables describe the transition rate or probability from the -->
<!-- first letter condition grade to the second letter condition grade. For example, -->
<!-- `cd` describes the proportion of the `unit_area` at `grade == C` that will -->
<!-- transition to `grade == D` through one timestep or year (`na` means from New to -->
<!-- A (excellent condition) and is not to be confused with `NA`).   -->

<!-- ## The blockbuster functions -->

<!-- We consider the first row of the sampled data which is a roof of excellent -->
<!-- `grade` A condition with a `unit_area` of 308.4. -->

<!-- ```{r} -->
<!-- test.element[1, ] %>% -->
<!--   dplyr::select(elementid, N, A, B, C, D, E, unit_area) -->
<!-- ``` -->

<!-- ## Deteriorating through time -->

<!-- Typically the user will be interested in a subset of the data. Consult the -->
<!-- `dplyr` vignette for handling and sub-setting your data based on desired filter -->
<!-- conditions.   -->

<!-- Here we demonstrate the deterioration of a single building component through -->
<!-- time. We chose a critical building feature of one particular block or building -->
<!-- we are interested in. CAVEAT: this modelling approach should be used at national -->
<!-- level; this example is illustrative. -->

<!-- ```{r, cache = TRUE} -->
<!-- my_roof <- dplyr::filter(test.element, -->
<!--                          buildingid == 4382, elementid == 1700) -->

<!-- my_roof_next_year <- Blockbuster(my_roof, save = FALSE) -->
<!-- my_roof_20year <- Blockbuster(my_roof, forecast.horizon = 20, save = FALSE) -->
<!-- my_roof_20year -->

<!-- ``` -->

<!-- This produces a `blockbuster` object which is a list of the `element` and -->
<!-- `block` objects providing the condition of the input tibble at that timestep. -->
<!-- The first list entry is for the input data. -->

<!-- ## Computation time -->

<!-- I suggest you spend time thinking about the precise question you are asking -->
<!-- rather than using the whole PDS dataset as input due to non-trivial computation -->
<!-- time. A 10% sample with rebuild and repair funding can easily take a couple of -->
<!-- hours on the DfE laptop used to produce this package (i5-6300U processor with  -->
<!-- 8Gb RAM). -->

<!-- The large number of components (each of which is a row in the associated -->
<!-- `element` object) can result in memory errors.  To help with this, interim  -->
<!-- `element` and `block` outputs are saved onto disc (by default into the ./output/ -->
<!-- folder) and reloaded to provide the final output.  Further work is planned to  -->
<!-- reduce the memory footprint of the model processes. -->

<!-- ## Plotting output basics -->

<!-- The `Blockbuster` package provides several default plot options for -->
<!-- `blockbuster` objects, utilising `ggplot2`.  The `blockbuster` objects need to -->
<!-- be manipulated into the long format required by `ggplot2` and this can take time -->
<!-- for very large datasets. For this reason, we advise using the functions -->
<!-- `LongArea` and `LongRepairBacklog` to prepare the data and then pass the results -->
<!-- into `ggplot` directly. -->

<!-- ### Blockbusting -->

<!-- We can investigate the rate at which our critical elements are deteriorating or -->
<!-- even what proportion of the `unit_area` is decommisioned. Given the flexibility -->
<!-- of the model output we can ask anything of the data.   -->

<!-- Here we are interested in tracking the deterioration of critical building -->
<!-- components in our block of interest.  We recycle the `my_roof_20year` object for -->
<!-- this question. The wall starts as all condition grade B then gradually -->
<!-- deteriorates. Several plot methods are available for `blockbuster` outputs. The -->
<!-- default method plots the repair backlog for all grades. -->

<!-- ```{r} -->
<!-- plot(my_roof_20year) -->
<!-- ``` -->

<!-- Adding the option `total = TRUE` plots the sum of all grade `C`, `D`, and `E` -->
<!-- backlogs instead. -->

<!-- ```{r} -->
<!-- plot(my_roof_20year, total = TRUE) -->
<!-- ``` -->

<!-- It is also possible to produce plots tracking the area of each grade. In the -->
<!-- following plot we can see the area at grade A has shrunk to 50% after twenty -->
<!-- years. -->

<!-- ```{r} -->
<!-- plot(my_roof_20year, type = "area") -->
<!-- ``` -->

<!-- The key components of these plots are the `area` and `backlog` class objects -->
<!-- generated by `LongArea()` and `LongRepairBacklog` respectively.  These are long -->
<!-- format data objects suitable for passing to `ggplot`. -->

<!-- ```{r} -->
<!-- area <- LongArea(my_roof_20year) -->
<!-- area -->
<!-- ``` -->

<!-- ```{r} -->
<!-- backlog <- LongRepairBacklog(my_roof_20year) -->
<!-- backlog -->
<!-- ``` -->

<!-- ### Critical building elements -->

<!-- Typically we may be more interested in critical, structural building-features  -->
<!-- such as the roof or walls and whether the `unit_area` exceeds a critical -->
<!-- threshold determined by expert opinion. For example, is our wall's total -->
<!-- `unit_area` after 10 years comprised of over 20% grade D and E? -->
<!-- We plot then inspect the numbers. -->

<!-- ```{r warning=FALSE, message=FALSE, error=FALSE, fig.width=9, fig.height=6} -->

<!-- my_roof_10 <- Blockbuster(my_roof, forecast.horizon = 10, save = FALSE) -->
<!--  #  We are interested in the 10 th (+ 1) timestep -->
<!--  df <- my_roof_10[[11]]$element -->

<!--  #  Use gov style for plot, install these if you don't have them -->
<!--  # devtools::install_github('mangothecat/visualTest')  #  required for govstyle -->
<!--  # devtools::install_github("UKGov-Data-Science/govstyle") -->

<!--  area <- LongArea(df) -->

<!--  plot(area) -->

<!-- ``` -->

<!-- The proportion of each element at a grade are stored in the `N`, `A`, `B`, `C`,  -->
<!-- `D`, and `E` columns of the associated `element` object.  It is therefore easy -->
<!-- to gauge if we have reached the 20% threshold by summing the appropriate -->
<!-- columns. -->

<!-- ```{r} -->
<!-- df$D + df$E -->
<!-- ``` -->

<!-- Only 4.8% of the wall area is at grade D or E. -->

<!-- ## Costing -->

<!-- Grade E is meant to encapsulate a decommisioned status.  However, it is more -->
<!-- useful to attempt to approximate the grade E cost using a crude estimate. Costs -->
<!-- for E grade are now simply the costs for D plus five percent. This approach was -->
<!-- recommended by Adam Bray until we get empirical estimates.       -->

<!-- Costs are calculated for each row within `element` objects. The `.repair.cost` -->
<!-- variables hold the cost per unit area for all components.  The `.repair.total` -->
<!-- values are simply the product of these and the unit area of each row. -->

<!-- The `.repair.cost` totals for buildings in the `block` summary are aggregated -->
<!-- from the `element` values. -->

<!-- ### Blockcosting -->

<!-- We continue with the examples from above by considering the aggregated cost of -->
<!-- repairs through time. Let us plot the distribution of costs by condition grade  -->
<!-- using a -->
<!-- [Tukey box plot](https://en.wikipedia.org/wiki/Box_plot#Alternative_forms) -->
<!-- through each year (R and ggplot make it easy to look at the data in different -->
<!-- ways). The `CreateElementBacklog` function generates a table of the repair -->
<!-- costs for each element at each grade.  The default plot method for the output  -->
<!-- (an `element.backlog` object) creates a faceted boxplot of element-wise repair -->
<!-- costs. -->

<!-- ```{r} -->
<!-- # deteriorate a block through 10 years -->
<!-- my_block_10years <- Blockbuster(my_block, forecast.horizon = 10, save = FALSE) -->

<!-- # compute the element.backlog -->
<!-- my_block_backlog <- CreateElementBacklog(my_block_10years) -->

<!-- # default plot method -->
<!-- plot(my_block_backlog) -->
<!-- ``` -->

<!-- Repair costs from grade A and N are always be zero as they are already in -->
<!-- excellent condition, so they are omitted from the plot. This plot shows how the median  -->
<!-- costs for each grade steadily increase year on year with some building -->
<!-- components in particularly deteriorating quickly and in a costly fashion -->
<!-- (the outliers indicated by the red circles).  -->

<!-- #### Boxplot interpretation -->

<!-- The red "dots" at the end of the boxplot represent outliers. These observations -->
<!-- contribute to the total cost of the block much more than others. There are a -->
<!-- number of different rules for determining if a point is an outlier, but the -->
<!-- method that R and ggplot use is the "1.5 rule". If a data point is:    -->
<!-- * `less than Q1 - 1.5 x IQR`   -->
<!-- * `greater than Q3 + 1.5 x IQR`   -->
<!-- then that point is classed as an "outlier". The line goes to the first data -->
<!-- point before the "1.5" cut-off. Note: the inter-quartile range; `IQR = Q3 - Q1`.   -->

<!-- ### Total Blockcosting -->

<!-- ### Line plot -->

<!-- The blockbuster output is flexible and amenable to data manipulation and or  -->
<!-- transformation prior to plotting. The user is only limited by their imagination.   -->

<!-- Below we present a standard output that is seen in many reports of the School -->
<!-- Estate. Here we plot the total costs aggregated by condition grade for each -->
<!-- year and give it a slightly prettier finish. Note how grade A components do not -->
<!-- contribute to the cost. However, the repair cost of E (set at D repair cost plus -->
<!-- five percent) accelerates the total cost as more building components' -->
<!-- `unit_area` transitions into grade E from D. It's important users are aware of -->
<!-- this when interpreting these graphics as the estimated cost of B, C and D should -->
<!-- be considered more reliable as they are based on expert opinion and bespoke -->
<!-- costs for each building component (whereas E grade is just 5% on D which may not -->
<!-- be appropriate for every building component).      -->

<!-- ```{r fig.width=9, fig.height=6} -->
<!-- plot(my_block_10years) -->
<!-- ``` -->

<!-- In the following plot which describes the total repair backlog of grade C and D -->
<!-- components observe that the costs start to plateau.  This may seem  -->
<!-- counter-intuitive until you realise that this means a substantial portion of the -->
<!-- component is grade E and needs rebuilding, not repair. -->

<!-- ```{r} -->
<!-- plot(my_block_10years, total = TRUE) -->
<!-- ``` -->

<!-- ### Digging down -->

<!-- > Better to draw several approximate graphics saying something about the right question than to draw one precise graphic relating to the wrong question. -->

<!-- The `blockbuster` simulation is time expensive thus we do not want to generate -->
<!-- every possible outcome variable that a user might need. Instead we generate -->
<!-- variables that are required for the simulation, for decision making regarding -->
<!-- which blocks should be rebuilt or repaired. Instead you can derive variables -->
<!-- yourself. Be imaginative and try plenty of variety in your plots. -->

<!-- ### Costing the rebuilding of a block -->

<!-- The repair costs ignore decommisioned building components (grade E `unit_area` -->
<!-- of a building component). To incorporate this into our analysis of when it is -->
<!-- better to rebuild a block rather than to maintain it we create a new variable -->
<!-- called `block_rebuild_cost`. This multiplies the `gifa`, of the block that the -->
<!-- building component in question is part of, by the argument `rebuild_cost_rate`  -->
<!-- which has a default value of £2000 per m^2^. This does not fully capture the  -->
<!-- complexity of estimating the rebuild cost of a block and could be enhanced in  -->
<!-- future iterations of the `blockbuster`. This value is the same for all building -->
<!-- components in the same block as it is a function of the block's `gifa`.  -->

<!-- In the following example we set the unit cost of rebuilding blocks at £2,507.5  -->
<!-- and apply an inflation rate of 4% which will be automatically applied to the  -->
<!-- repair and rebuild costs each year. -->

<!-- ```{r} -->

<!-- two_blocks_4_years_inflation <- Blockbuster(dplyr::filter(test.element, -->
<!--                                                           buildingid == 4382 | -->
<!--                                                           buildingid == 4472), -->
<!--                                             forecast.horizon = 4, -->
<!--                                             block.rebuild.cost = 2507.5, -->
<!--                                             inflation = 1.04, -->
<!--                                             save = FALSE) -->

<!-- # initial rebuild cost -->
<!-- sum(two_blocks_4_years_inflation[[1]]$block$block.rebuild.cost) -->
<!-- # cost after four years of inflation at 4% -->
<!-- sum(two_blocks_4_years_inflation[[5]]$block$block.rebuild.cost) -->
<!-- ``` -->

<!-- Note that deterioration does not affect the cost of rebuilding a block, only -->
<!-- inflation. -->

<!-- #### Total costs by building element -->

<!-- The `element.backlog` object gives us the ability to drill into -->
<!-- individual components.  For example, we can look at the costs related to  -->
<!-- particular element types.  In the next example we only look at the elementid -->
<!-- related to structural walls and roofs. -->

<!-- ```{r fig.width=9, fig.height=6} -->

<!-- my_block_structure_backlog <- my_block_backlog %>% -->
<!--   filter(elementid %in% c(1863, 1830, 1983, 1862, 1826, 1829, 1984, 1827, 1828, -->
<!--                           1864, 1701, 1985, 1700, 1865)) %>% -->
<!--   ElementBacklog -->

<!-- plot(my_block_structure_backlog) -->

<!-- #p5 <- my_block_10years %>% -->
<!-- #  purrr::map_df( -->
<!-- #    ~ .x , -->
<!-- #    .id = NULL -->
<!-- #  ) %>% -->
<!-- #  dplyr::group_by(timestep, element) %>% -->
<!-- #  dplyr::summarise(sum_cost = sum(cost, na.rm = TRUE)) %>% -->
<!-- #  ggplot2::ggplot(aes(x = element, y = sum_cost)) + -->
<!-- #  ggplot2::geom_bar(stat = "identity") + -->
<!-- #  ggplot2::facet_wrap( -->
<!-- #    ~timestep -->
<!-- #  ) -->

<!-- #p5 + ylab("Total cost of repairs (£)") + xlab("Building element") + -->
<!-- #  govstyle::theme_gov() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  -->
<!-- #  theme(plot.margin = unit(c(20,10,10,10),"mm")) -->

<!-- ``` -->

<!-- #### Subsetting the blockbuster list output for specified years of interest -->

<!-- Perhaps we are interested in just the last couple of years of the simulation? We can subset a single year of interest or dataframe from the list using the normal R syntax.   -->

<!-- The following graph also highlights a flaw in the earlier generation of the deterioration model which just considered the `unit_area` of a building component and ignored the building component `element`, `sub_element` or `const_type` type in its calculations. The blockbuster model considers this when estimating repair costs. In the figure below we aggregate across building `element` the total `unit_area` and `cost` of repairs and plot using the extra dimensions afforded by point area and colour. In short this identifies an interaction term between `element` and `grade` for `cost` of repairs (the trajectory of gradient is different between building components as you go between condition grades).     -->

<!-- ```{r fig.width=9, fig.height=6} -->
<!-- #p6 <- my_block_10years[11] %>% -->
<!-- #  purrr::map_df( -->
<!-- #    ~ .x , -->
<!-- #    .id = NULL -->
<!-- #  ) %>% -->
<!-- #  dplyr::group_by(timestep, grade, element_shrt = as.factor(abbreviate(element, 14))) %>% -->
<!-- #  dplyr::summarise(sum_unit_area = sum(unit_area, na.rm = TRUE), -->
<!-- #                   sum_cost = sum(cost, na.rm = TRUE)) %>% -->
<!-- #  ggplot2::ggplot(aes(x = grade, y = sum_cost, colour = element_shrt, size = sum_unit_area)) + -->
<!-- #  ggplot2::geom_point(alpha = 0.7) + -->
<!-- #  ggplot2::facet_wrap( -->
<!-- #    ~ timestep -->
<!-- #  ) -->

<!-- #p6 + ylab("Cost of repairs (£)") + xlab("Condition grade")  + -->
<!-- #  theme_economist() +  -->
<!-- #  scale_size_continuous(breaks = c(1000, 2000, 3000), range = c(3,10)) -->

<!-- ``` -->

<!-- ## Rebuilding -->

<!-- Rebuilding is carried out by the `rebuild` function which is internal to `blockbuster`. The rebuilding of the `blockbuster_tibble` you pass as an argument is dependent on two other arguments; the `rebuild_monies` and `rebuild_cost_rate`. Both can be passed as a vector equal in length to the number of years you are simulating (`forecast_horizon`) or as a number. This allows you to control for inflation in the construction industry and variable rebuilding spending from year to year. Technically the `blockbuster` function makes use of the `rebuild_cost_rate` in estimating how much it would cost to rebuild a block (`rebuild_cost_rate` multiplied by block `gifa`), this is then passed into `rebuild` for a decision on how to spend the available `rebuild_monies`. All the blocks (unique based on `buildingid`) in the `blockbuster_tibble` are ranked in descending order of the ratio of the total cost of repairs to the cost of rebuilding the block (where a score higher than one means the block is more expensive to repair than it is to rebuild). The block with the highest internal statistic of `cost_to_rebuild_ratio` is inspected for rebuilding first. If enough monies are available it is rebuilt by converting all its building components back to new and recalculating the `unit_area` (using `areafy2`). The leftover money is then cycled through the list rebuilding as appropriate until the remaining money is less than the cheapest block to rebuild, at which point it is discarded (NOT passed to `repair_monies`).   -->

<!-- ### Example -->

<!-- We inspect the effect of rebuilding on the cost of repairs of three buildings with a non-constant rebuilding investment profile and `rebuild_cost_rate` adjusted for 0% (year 2) then 1% inflation (year 3) (you can pass this as a vector rather than typing it manually of course). We inspect the effect of the rebuild on total repair costs using a faceted stacked bar chart for the different building elements in all the blocks (try increasing the `rebuild_monies` by one pound, what happens?). -->

<!-- ```{r fig.width=10, fig.height=12} -->
<!-- #  We filter our PDS sample for just three blocks to keep things simple -->
<!-- #x <- dplyr::filter(blockbuster::blockbuster_pds,  buildingid == 4382 | buildingid == 4472 -->
<!-- #                   | buildingid == 4487) -->
<!-- ##  Rebuild spending profile -->
<!-- #y <- blockbuster(x, forecast_horizon = 8, rebuild_monies = c(0, 5e6, 0, 0, 0, 0, 0, 0),  #  #five million -->
<!-- #                 rebuild_cost_rate = c(1274, 1274 + 0, 1274 + 12.74, 1286.74, 1286.74, -->
<!-- #                                       1286.74, 1286.74, 1286.74))   -->

<!-- #p7 <- y %>% -->
<!-- #  purrr::map_df( -->
<!-- #    ~ .x , -->
<!-- #    .id = NULL -->
<!-- #  ) %>% -->
<!-- #  dplyr::group_by(timestep, element, grade) %>% -->
<!-- #  dplyr::summarise(sum_cost = sum(cost, na.rm = TRUE)) %>% -->
<!-- #  ggplot2::ggplot(aes(x = element, y = sum_cost, fill = grade)) + -->
<!-- #  ggplot2::geom_bar(stat = "identity") + -->
<!-- #  ggplot2::facet_wrap( -->
<!-- #    ~timestep -->
<!-- #  ) + scale_fill_discrete(drop = FALSE) + scale_x_discrete(drop = FALSE)  #  gives E a colour -->

<!-- #p7 + ylab("Total cost of repairs (£)") + xlab("Building element") + -->
<!-- #  govstyle::theme_gov() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  -->
<!-- #  theme(plot.margin = unit(c(20,10,10,10),"mm")) + -->
<!-- #  theme(legend.position = "top")  -->
<!-- ``` -->

<!-- This also provides a sense check. The rebuild happens during `timestep 2` (because `rebuild_monies = c(0, 5e6, 0)`), all building components are rebuilt to `grade = N` thus have  zero `cost`. During the next timestep there will be some deterioration to `grade = A`, however all building components of excellent condition do not contribute to the repair costs of a block, hence no cost of repairs in `timestep 3`. We start to see condition `grade = B & D` at `timestep 5` as expected given our working knowledge of the model.   -->

<!-- ## Repairs -->

<!-- Repairs are carried out by the `repair` function which is internal to `blockbuster`. The repairing of the `blockbuster_tibble` you pass as an argument is dependent on the other argument; `repair_monies`. The latter can be passed as a vector equal in length to the number of years you are simulating (`forecast_horizon`) or as a number. This allows you to control for inflation in the construction industry and variable repairs spending from year to year. Technically the `blockbuster` function makes use of the `repair_monies` by dividing it up evenly between each block in the input `blockbuster_tibble`.   -->

<!-- All the blocks (unique based on `buildingid`) in the `blockbuster_tibble` are ranked in descending order by `buildingid`, `grade` (from E to N) and `cost` (expensive to cheapest repairs within `grade`). Each block is repaired with `repair_monies` divided by the number of blocks in the `blockbuster_tibble`. Money is spent on worse condition grade (ignoring E as it cannot be repaired [ignoring N and A also]) and most expensive repairs first until the remaining money is less than the cheapest building component to repair, at which point it is discarded (NOT passed to `rebuild_monies`; assumed spent by the school on other things) (see the help function `what_needs_repair_within_block()` for details on the decision making). -->

<!-- ### Example - compare different spending profiles on condition of blocks -->

<!-- The purpose of this package is to inform policy decision making to determine which out of competing spending profiles will better meet the assessment criteria. Here we aim to minimise the total condition cost of repairs in the 3 school blocks. We develop two spending profiles using the same amount of money over five years (ignoring inflation for simplicity). Remember, the user is free to develop their own assessment criteria given the flexibility of the model output (e.g. you could use the `unit_area` of critical building components).   -->

<!-- We could compare using some graphics already demonstrated in the vignette. Instead we prefer to reorganise the data to answer our specific question: which of our competing spending profiles produces the lowest estimated total repairs cost in year 5? We use arbitary blocks and total repair spend profile (this is not intended to be realistic but instead demonstrative). Inspect the code chunk, specifically the `repair_monies` argument for each spending profile, as it is where they differ.   -->

<!-- * Drip - slow and steady - consistent amount spent each year. -->
<!-- * Flood - sooner rather than later - spending more sooner, less later. -->

<!-- #### Run the simulations -->

<!-- ```{r } -->
<!-- #  We filter our PDS sample for just three blocks to keep things simple -->
<!-- #  using identical blocks to our rebuild example above. -->
<!-- # -->
<!-- #x <- dplyr::filter(blockbuster::blockbuster_pds,  buildingid == 4382 | buildingid == 4472 -->
<!-- #                   | buildingid == 4487) -->
<!-- ##  Repair spending profile of different strategies -->
<!-- #drip_repairs <- blockbuster(x, forecast_horizon = 5,  #  sum(rep(3e4, 5)) -->
<!-- #                            repair_monies = rep(3e4, 5))  #  £10k / block / year = £ 15e5 -->
<!-- # -->
<!-- #flood_repairs <- blockbuster(x, forecast_horizon = 5, -->
<!-- #                             repair_monies = c(6e4, 6e4, -->
<!-- #                                               1e4, 1e4, 1e4))   -->
<!-- ##  (20k, 20k, 5k, 5k, 5k)* 3 blocks = £ 10.5e5# -->
<!-- # -->
<!-- ``` -->

<!-- Sometimes it is convenient to save these objects and then use them again later. If we were to `saveRDS` then `readRDS` we could use the `attributes()` function to find out the spending profile inputs of the `blockbuster_list`. -->

<!-- ```{r} -->
<!-- #attributes(drip_repairs) -->
<!-- #attributes(flood_repairs) -->

<!-- ``` -->


<!-- #### Manipulate data for assessment statistic of interest (total cost of repairs) -->

<!-- This consistent repair spend profile can be visually compared by the user to a spending profile that invests more heavily sooner rather than later. However, we need to organise the data into a convenient form for comparison.   -->

<!-- First we convert our list of dataframes into one dataframe (for each spending profile).   -->

<!-- ```{r} -->
<!-- #drip <- dplyr::bind_rows(drip_repairs) -->
<!-- #flood <- dplyr::bind_rows(flood_repairs) -->

<!-- ``` -->

<!-- Then we group by timestep and sum the total cost of repairs across all the blocks. We pretend you might want to compare many spending profiles here and thus demonstrate an approach that can be scaled. The model comparison of spending profiles suggests that the flood approach is slightly better when judged by the year 5 `total_cost` of repairs statistic generated using simple data manipulation and aggregation by the analyst. Not much difference at year 1 suggests that the "spend early" strategy may have over spent at year 1. This could be explored by further investigation or even automation to optimise the problem, given enough time or computation power.   -->

<!-- ```{r} -->
<!-- #dripping <- drip %>%  #  extracat::visna(drip, sort = "b") -->
<!-- #  group_by(timestep) %>%  #  drip_missing <- drip %>% filter(!complete.cases(.)) -->
<!-- #  #  table(drip_missing$timestep)  #  the originals rows are not being given this variable -->
<!-- #  #  maybe this is OK and makes sense, block can't be rebuilt at timestep 0, therefore NA cost -->
<!-- #  summarise(total_cost = sum(cost))# -->
<!-- # -->
<!-- #flooding <- flood %>% -->
<!-- #  group_by(timestep) %>% -->
<!-- #  summarise(total_cost = sum(cost))# -->

<!-- #  we can join them and create an ID variable -->
<!-- #spending_profile_ts <- dplyr::bind_rows("drip" = dripping, "flood" = flooding, -->
<!-- #                                        .id = "spend_profiles") -->

<!-- #spending_profile_ts -->
<!-- ``` -->

<!-- #### Visualise -->

<!-- ```{r} -->
<!-- #p8 <- ggplot(spending_profile_ts, aes(timestep, -->
<!-- #                                total_cost, -->
<!-- #                                colour = spend_profiles, -->
<!-- #                                group = spend_profiles)) + -->
<!-- #  geom_line(size = 2)# -->
<!-- # -->
<!-- #  p8 <- p8 + ylab("Total cost of repairs (£)") + xlab("Years") + -->
<!-- #  govstyle::theme_gov() +  -->
<!-- #  theme(plot.margin = unit(c(20,10,10,10),"mm")) + -->
<!-- #  theme(legend.position = "top") -->
<!-- # -->
<!-- ``` -->

<!-- ```{r fig.width=10, fig.height=12} -->
<!-- #print(p8) -->
<!-- ``` -->

<!-- The simulations suggest that on average investing sooner rather than later with the "flood" strategy is slightly superior at reducing total repair costs in five years time.   -->

<!-- ## Rebuilding versus repairing - how to best invest? -->

<!-- Now we have both the `rebuild` and `repair` functions we can assess spending profiles that prioritise rebuilding over repairing or vice versa. Again to compare meaningfully we need an assessment criteria to compare our different approaches.   -->

<!-- Let's use all our money to rebuild one of the blocks or use all the money to repair each block over the five years instead.   -->

<!-- * Rebuild one block at year one then do nothing   -->
<!-- * Repair each block over the five years using block rebuild investment   -->

<!-- We use the same arbitary grouping of blocks to demonstrate. We do our analysis in one code chunk this now that you are familiar.   -->

<!-- ```{r } -->
<!-- #  Repair spending profile of different strategies -->

<!-- #  rebuild most expensive block in first year -->
<!-- #rebuild_once <- blockbuster(x, forecast_horizon = 5,   -->
<!-- #                            rebuild_monies = c(2440984, rep(0, 4))) %>% -->
<!-- #  dplyr::bind_rows() %>% -->
<!-- #  group_by(timestep) %>% -->
<!-- #  summarise(total_cost = sum(cost, na.rm = TRUE)) -->

<!-- #  repair funding using same funds spread over five years -->
<!-- #drip_fix <- blockbuster(x, forecast_horizon = 5, -->
<!-- #                             repair_monies = rep(2440984/5, 5)) %>%  -->
<!-- #  dplyr::bind_rows() %>% -->
<!-- #  group_by(timestep) %>% -->
<!-- #  summarise(total_cost = sum(cost, na.rm = TRUE))# -->

<!-- #  we can join them and create an ID variable -->
<!-- #spending_profile_ts <- dplyr::bind_rows("Repairs only" = drip_fix, -->
<!-- #                                        "Rebuild only" = rebuild_once, -->
<!-- #                                        .id = "spend_profiles") -->

<!-- #p9 <- ggplot(spending_profile_ts, aes(timestep, -->
<!-- #                                total_cost, -->
<!-- #                                colour = spend_profiles, -->
<!-- #                                group = spend_profiles)) + geom_line(size = 2) -->

<!-- #  p9 <- p9 + ylab("Total cost of repairs (£)") + xlab("Years") + -->
<!-- #  govstyle::theme_gov() +  -->
<!-- #  theme(plot.margin = unit(c(20,10,10,10),"mm")) + -->
<!-- #  theme(legend.position = "top") -->


<!-- ``` -->

<!-- ```{r fig.width=10, fig.height=12} -->
<!-- #print(p9) -->
<!-- ``` -->


<!-- The rebuild takes care of the one rebuilt block but not the other two! As a result the costs of repair begin to accelerate without any money invested in repairing the blocks. The repair focused spending profile quickly brings the condition cost down to zero after two years. The repair profile is probably overspending in the subsequent years and funding could be reduced further with some investigation.   -->

<!-- CAVEAT: this is just a demonstration and should not be considered a general rule. The best strategy will depend on your assessment criteria and the blocks of interest.   -->

<!-- ## Summary -->

<!-- * This modelling approach has the potential to make use of all the data.   -->
<!-- * It uses a robust statistical modelling approach.   -->
<!-- * The input structure is preserved in the output tibbles.   -->
<!-- * The model can be iteratively improved as more data is collected.   -->
<!-- * There is flexibility in the transition matrices that are used that should be estimated empirically in the future, data collection permitting. -->
<!-- * The writing of a package allows us to enshrine business knowledge into a corpus of code that is inseparable from the documentation of that code. -->
<!-- * Quality assurance is built in through the use of continuous integration and the test driven development.   -->

<!-- ```{r} -->
<!-- sessionInfo() -->
<!-- ``` -->

