% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair_functions.R
\name{Repair}
\alias{Repair}
\title{Repair elements by expected cost at a grade}
\usage{
Repair(element.data, repair.money, grade.order = c("E", "D", "C", "B"))
}
\arguments{
\item{element.data}{An element-level data frame.}

\item{repair.money}{A number.}

\item{grade.order}{(Optional) A vector of character strings from \code{"E"},
\code{"D"}, \code{"C"} and \code{"B"} in any order.  This determines the
priority for repairs.  The first character gives the first grade that will
be repaired. By default, E is repaired first, then D, then C, then B.}
}
\value{
An element-level data frame with the grade proportions
amended accordingly.
}
\description{
Given the current state of the buildings, this function outputs the element-
level status after repairing components within budget.
}
\details{
The repairing gives priority to repairing those components with the highest
expected cost at grade E, then grade D, then grade C, then grade B, although
this order can be adjusted using the arguement \code{grade_order}. It calls
the same \code{\link{RecursiveBudgeting}} recursive algorithm used by
\code{\link{Rebuild}} to efficiently identify the most at risk
components within budget.

This function does NOT update the repair costs, only the grade proportions.
Therefore \code{\link{UpdateElementRepairs}} and
\code{\link{UpdateBlockRepairs}} should be called on the element- and block-
level objects afterwards to ensure the repair costs and totals are correct.
}
\examples{
# Repair elements with a budget of Â£100,000
repaired_elements <- blockbuster2:::Repair(simulated_elements, 100000)
# IMPORTANT - This does not update repair costs
blockbuster2:::UpdateElementRepairs(repaired_elements)
# UpdateBlockRepairs uses the updated element-level data to update the block-
# level data frame so it should also be run.
blockbuster2:::UpdateBlockRepairs(simulated_blocks, repaired_elements)
}
