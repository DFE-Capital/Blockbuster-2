% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair_functions.R
\name{Repair}
\alias{Repair}
\title{Repair elements in a block}
\usage{
Repair(element.data, block.data, repair.money, grade.order = c("D", "C", "B"))
}
\arguments{
\item{element.data}{An \code{\link{element}} class object.}

\item{repair.money}{A number.}

\item{grade.order}{(Optional) A list of the three character strings \code{"D"},
\code{"C"} and \code{"B"} in any order.  This determines the priority for
repairs.  The first character gives the first grade that will be repaired.
By default, D is repaired first, then C, then B.}
}
\value{
An \code{\link{element}} class object with the grade proportions
amended accordingly.
}
\description{
Given the current state of the buildings, this function outputs the element-
level status after repairing components within budget.
}
\details{
The repairing gives priority to repairing those components at greatest risk
of being grade D, then grade C, then grade B. It calls the same
\code{\link{RecursiveBudgeting}} recursive algorithm used by
\code{\link{Rebuild()}}function to efficiently identify the most at risk
components within budget.

The argument \code{block.data} is deprecated and not used in this function.
It is left in for modularity purposes as at a later data it may be that
several repair decision algorithms are selectable and some may require
the block-level information.

This function does NOT update the repair costs, only the grade proportions.
Therefore \code{\link{UpdateElementRepairs}} and
\code{\link{UpdateBlockRepairs}} should be called on the element- and block-
level objects afterwards to ensure the repair costs and totals are correct.
}
