% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recursive2.R
\name{RecursiveBudgeting2}
\alias{RecursiveBudgeting2}
\title{Find blocks to rebuild within budget recursively.}
\usage{
RecursiveBudgeting2(vec, keys, budget, state = NULL)
}
\arguments{
\item{vec}{A numeric vector. When called by \code{\link{Rebuild}} this
contains the cost of rebuilding blocks.}

\item{keys}{A vector. When called by \code{\link{Rebuild}} this contains the
\code{buildingids} associated with the costs in \code{vec}.}

\item{budget}{A number.}

\item{state}{(optional) This holds the selected keys during recursion.}
}
\value{
A list.  \code{.$state} holds the selected keys while \code{.$budget}
holds the unused budget.
}
\description{
An efficient recursive algorithm used by \code{\link{Rebuild}} that outputs
the \code{keys} corresponding to the unique combination of elements in the
ordered vector \code{vec} that sum to less than \code{budget}.
}
\details{
The cumulative sum of the repair costs are computed and the vector split at
the largest amount that does not go over the budgeted amount.  The first
part is tagged to be fixed, and the second part is fed back into the
function with the remaining budget.
}
\examples{
# Ten buildings have rebuild costs between one to ten. Spend 12 to rebuild
# the first four
blockbuster2:::RecursiveBudgeting(1:10, 1:10, 12)
# If the costs are reversed, the decision changes as the vector is ordered
blockbuster2:::RecursiveBudgeting(10:1, 1:10, 12)
}
